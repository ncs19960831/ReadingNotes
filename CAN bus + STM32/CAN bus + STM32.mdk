Title         : CAN总线+STM32的学习心得与笔记整理
Author        : GreenDreamer
Logo          : False

[TITLE]
****
**题注：至于CAN有多牛逼以及有多有前景这种文字我就懒得复制粘贴了。一切争取最简！**

**关于为何写下这篇文章**：因为最近单位需要做关于STM32使用CAN总线进行数据收发的设备，而本人恰巧对于CAN总线几乎一无所知。所以断断续续了解了几天之后写下了本文。且因为网上对于STM32的CAN资料太过松散，我也将其整理了整理，并且加了自己的一点私货，以作总结。

# CAN总线的规范数据格式
CAN总线主要的规范是ISOXXXXX，其规范格式中指出：CAN总线的主要数据为其报文主体。整个报文+各种ID与标志位组成了可以被发送的**帧**。
其中，帧又分为了以下的5种：


* 1.**数据帧**，由于发送方传输给接收方数据。
* 2.**帧间隔**，两帧之间发送的数据间隔帧。
* 3.**摇控帧**，接收端发送给发送端自身的ID，便于建立网络表。
* 4.**错误帧**，接收端发现数据错误的时候向发送端发送帧。
* 5.**过载帧**，接收端无法及时处理当前帧的时候发送。

每个帧主要分为以下七个部分

* 1.**帧起始**:表示数据帧开始的段。 
* 2.**仲裁段**:表示该帧优先级的段。 
* 3.**控制段**:表示数据的字节数及保留位的段。 
* 4.**数据段**:数据的内容，一帧可发送0~8个字节的数据。 
* 5.**CRC段**:检查帧的传输错误的段。 
* 6.**ACK段**:表示确认正常接收的段。 
* 7.**帧结束**:表示数据帧结束的段。 

其中，标准帧的布局格式主要是这样的：

**帧起始[0]+帧ID[1:12]+RTR+IDE+R0[13:15]+DTC[15:18]+DATA[19:82]+CRC32[83:98]+CRC EOF+ACK+ACK EOF[99:101]+EOF[102:108]**

扩展ID数据帧主要区别在于仲裁段的区别。其余的数据皆是一样的。

**帧起始**：标准帧和扩展帧都是由1个位的显性电平表示帧起始。
 
**仲裁段**：表示数据优先级的段，标准帧和扩展帧格式在本段有所区别，标准格式的ID 有11 个位。从ID28 到ID18 被依次发送。禁止高7 位都为隐性（禁止设定：ID=1111111XXXX，原因：can通信采用的是NZR编码，而can的仲裁是靠数据帧中的ID部分来实现的，全为隐性状态，可能导致仲裁失败！）。扩展格式的 ID 有29 个位。基本ID 从ID28 到ID18，扩展ID 由ID17 到ID0 表示。基本ID 和标准格式的ID 相同。禁止高7 位都为隐性（禁止设定：基本ID=1111111XXXX）。 
其中RTR位用于标识是否是远程帧（0，数据帧；1，远程帧），IDE位为标识符选择位（0，使用标准标识符；1，使用扩展标识符），SRR位为代替远程请求位，为隐性位，它代替了标准帧中的RTR位。 

**控制段**：由6个位构成，表示数据段的字节数。 
数据段，该段可包含0~8个字节的数据。从最高位（MSB）开始输出，标准帧和扩展帧在这个段的定义都是一样的。 

**CRC段**：该段用于检查帧传输错误。由15个位的CRC顺序和1个位的CRC界定符（用于分隔的位）组成，标准帧和扩展帧在这个段的格式也是相同的。 

**ACK段**：此段用来确认是否正常接收。由ACK槽(ACK Slot)和ACK界定符2个位组成。标准帧和扩展帧在这个段的格式也是相同的。

而ID的主要作用是充当一个“地址”的角色。但是因为CAN总线协议内部其实没有真正的总线地址，所有数据都是直接广播发送的。所以严格上来讲，其实ID更像是一个约定的过滤码一般。所有数据经过了ID的过滤，使得符合ID格式的数据被器件接收，不符合的被器件丢弃，避免了广播风暴。

ID的校验主要是使用波形校验+高位抢占的模式。由CAN总线的电气参数可知，整个CAN是以差分电平进行数据传输的。所有的数据都是由**隐性电平（1）**和**显性电平（0）**组成。其中，显性电平是指两个传输电平之间的信号的差为正值，隐性电平则为两个传输电平之间的信号的差为零（共模数据）。而ID的传输就是将ID数据通过上述的方式进行译码传输。当发送端发出第一个ID的二进制位时，网络中**所有的器件**（除发送端）都会接收到当前二进制数并且与自身约定好的ID的第一位数据进行比对，如果一致则接着向下比对。**要注意的是，单个节点需接受的地址为0x11001100，主机发出0x11001011，则在第6个数据位发送之后，此节点选择不接该数据包。除非所有字符皆匹配，否则拒绝接收。**

CAN总线的ID主要为两种：标准ID与扩展ID。其中，标准ID为**11位**，扩展ID为**18位**，且扩展ID与标准ID组成的帧格式几乎完全不同。但是扩展ID组成的帧必定会包含标准ID。会出现两种ID的原因主要是因为有可能现场设备太多，ID分配不均。所以使用更多的ID会使当前CAN总线最多带起100~200的设备。

#CAN总线的波特率计算方式

位速率：发送设备每秒发送的数据位数被称为位速率。一位可以分为4段时间：

* 1.同步时间（SS）
* 2.传播时间段（PTS）
* 3.相位缓冲段1（PBS1）
* 4.相位缓冲段2（PBS2）

这些段在公式中可以使用时间元确定（Time quantum）。

其中，STM32中bxCAN将相位缓冲段1和传播时间段合并为时间段1（BS1），而剩下的并没有什么变化。所以bxCAN的波特率分为三段时间：

~ Aligned
 SYSNC_SEG（SS）+BS1(PTC+PBS1)+BS2(PBS2). 
~  

STM32的BS1段可以设置为1~16个时间单元，刚好等于上面介绍的传播时间段和相位缓冲段1之和。

而主要计算公式为：

~ Equation 
\begin{aligned}
  band=1/bit_{time}  \\ 
  bit_{time}=1*t_q+t_{BS1}+t_{BS2} \\
  t_{BS1}=t_q*(TS1[3:0]+1) \\
  t_{BS2}=t_q*(TS2[2:0]+1) \\
  t_q=(BRP[9:0]+1)*t_{PCLK}  \\
  t_q=Time\ Quantum  \\
  t_{PCLK}=APB Clock。  
\end{aligned}
~

# ID过滤方式

CAN的协议中，没有任何地址数据，所有的数据帧全部都是广播发送。取而代之的是由11到29个ID组成的类似地址的数组，主要是接收端使用，而发送段可以指定自己为任意的ID地址。接收端通过ID地址过滤的方式进行数据清洗，只接受自己所需要的数据。为了加快数据清洗的速度，接收端采用了按位比较的方式进行数据清洗，具体方法在前文已经说过这里不在细表。

在STM32中，bxCAN使用了两种寄存器进行ID的过滤，一种是16位寄存器（接收11位标准ID）,另一种是32位寄存器（接收29位扩展ID）。而自带的硬件会自动将数据与其协议进行数据比对，筛选出所需要的数据，用户只需要配置好ID和状态位即可，相应的状态标志位主要使用中断来进行查询处理。其中，过滤方式主要分为两种：**屏蔽**、**列表**

* 屏蔽模式：

顾名思义，就是以屏蔽不需要关心的ID来达到筛选ID的目的，其中：

**0：不必比较，发送器ID可以为0也可以为1；**

**1：必须一致，为主要屏蔽位。**

* 列表模式：

将寄存器中的ID看作列表的形式，只要发送端ID和列表ID完全吻合的时候数据才会被接收。

* 两者区别：

屏蔽模式的过滤策略偏向于关键字过滤，会有一定的误判，例如mask为0b00010010，需要接受的ID为0b0010111，但是这个时候0b00010011、0b00010110也会被接收端接收到，所以需要在中断函数中再做判断以保证不会出错。

列表模式的过滤策略偏向于白名单过滤，可以得到的ID很少，但是结果足够精确，可以准确识别当前需要读取的数据，但是由于存储器限制，只能最多存储4个16位ID或2个32位ID。

这里我还有个疑问，从各种资料上来看，MASK位是要早于ID位进行筛选的，但是很多资料上说过滤多个ID的时候，ID位设置为任何一个需要关注的ID都可以，而MASK位需要将所有需要关注的ID进行同或之后放入。如果是MASK先做检查的话，根据前文所说，是否ID位的作用就消失了呢？而且STM32官方的例子里面MASK为0，而ID做了赋值。如果是按照其他文章上所说的任意ID皆可的话，是否会筛选出来很多不需要的ID？也许是我在刚开始的时候理解CAN的过滤机制出现了偏差，这还需要继续研究，以待更新
前面说的是总线仲裁模式，搞混了，难怪无法理解。屏蔽模式下不识别0，发送器ID与MASK同或为MASK的话就直接通过，再与过滤器ID进行与运算为MASK则说明接收到了需要关心的ID。因为之前的MASK就为所有需要关心ID的同或，所以需要关心的ID随便设一个就好。然后在中断函数内部就可以对ID进行分类处理

而STM32 提供了14个寄存器组进行ID数据的比对和帧格式的确定，所有寄存器皆为32位并部分可以向下兼容16位寄存器。所有的寄存器被存放在两个FIFO中，如下图：
****
插图
****

下图中，左侧为当前分配的寄存器组编号，右侧为可以使用的寄存器的数目，中间则为寄存器组的功能，可以在使用相应模式的时候进行对应的选择。

# 引脚重映射
在STM32中，bxCAN有两个，且引脚主要分为三组，PA11\~12、PB8\~9、PD1\~2（部分芯片没有PD，上述资料来自于STM32F103c8t6参考手册），并通过重映射进行选择。默认状态下选择的是PA11\~12。但是很多时候需要更改引脚进行使用。其中，库函数3.5中提供了remap1和remap2。在STM32F103C8T6中，remap1为PA，remap2为PB。虽然手册里有关于PD的配置，但是F103并没有PD，所以就不能配置。

#CAN模式选择
bxCAN提供了10个模式共用户使用。他们分别是：**DBF、RESET、TTCM、ABOM、AWUM、NART、RFLM、TXFP、SLEEP、INRQ**。

我*！这都是什么缩写，当时我就蒙圈了，于是在翻阅了参考手册（P~674~）的情况下得到了以下的全写与机（ren）器（gong）翻译：

* 1.DBF—— Debug freeze——断点调试？ 
* 2.RESET——重置，没啥可说的
* 3.TTCM——Time triggered communication mode——时间触发通讯模式
* 4.ABOM—— Automatic bus-off management——自动总线管理
* 5.AWUM—— Automatic wakeup mode——自动唤醒模式
* 6.NART——No automatic retransmission ——不自动重传
* 7.RFLM——Receive FIFO locked mode ——接收FIFO锁定模式
* 8.TXFP—— Transmit FIFO priority ——优先发送FIFO模式
* 9.SLEEP—— Sleep mode request ——睡眠模式开关
* 10.INRQ——  Initialization request——初始化开关

具体参考参考手册P~674~有很详细的配置结果与模式说明。参考手册为[RM0008]，官网有下。

**到此，STM32对于CAN数据的过滤校验基本上就算完成了。示例代码在官方手册里面就有，这里就不贴了。谨在此标记一下参考文档中关于各个参数的定位**

# 程序初始化配置
程序中，因为需要用到CAN总线，本例拟定使用PA接口，所以需要将CAN_TX的GPIO设为：

* 复用推挽输出/开漏输出+硬件上拉电阻，因为没有上拉电阻，所以选择复用推挽输出。
* 频率定为50MHz（不限定功耗的情况下）

因为CAN_RX并非为全低电平，所以需要使用一个内部弱上拉进行数据的接收，所以需要配置其为内部上拉电阻输入模式。因为内部上拉电阻大约在100
~Math
\Omega
~
所以可以完成线阻匹配

CAN的初始化流程基本为：声明初始化结构体-->将结构体赋为初值-->配置结构体相应的数据-->将其导入寄存器-->打开时钟-->打开中断

这套流程相信只要经常用STM32库函数进行开发的人都会十分熟悉，而且可以熟练掌握。但是在使用的时候需要注意，CAN发报的形式是使用类似于短消息的形式进行发送，必须要使用CANTxMessage进行结构体声明，并配置好需要发送的帧格式和数据后进行发送。

数据的接收和其他外设大同小异，主要使用中断函数进行数据的接收，但是因为F103的PA相应引脚也是USB的引脚，所以在非互联型且带有CAN的设备中，中断函数被声明为**USB_LP_CAN1_RX0_IRQHandler**。

上述就是我对于STM32关于整个CAN的支持方案的摸索，历时2~3天（最近很咸鱼）写下此这文章以作备忘

[RM0008]:<http://www.st.com/content/ccc/resource/technical/document/reference_manual/59/b9/ba/7f/11/af/43/d5/CD00171190.pdf/files/CD00171190.pdf/jcr:content/translations/en.CD00171190.pdf>